<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Bruce的博客</title><link>https://www.yss520.online/zh/posts/</link><description>Recent content in Posts on Bruce的博客</description><generator>Hugo -- 0.145.0</generator><language>zh</language><lastBuildDate>Wed, 30 Aug 2023 00:12:39 +0800</lastBuildDate><atom:link href="https://www.yss520.online/zh/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Vite Compile Optimization</title><link>https://www.yss520.online/zh/posts/vite-compile-optimization/</link><pubDate>Wed, 30 Aug 2023 00:12:39 +0800</pubDate><guid>https://www.yss520.online/zh/posts/vite-compile-optimization/</guid><description>&lt;h1 id="vite-构建-react-项目的极致优化从-2-分钟到-8-秒的构建革命">Vite 构建 React 项目的极致优化：从 2 分钟到 8 秒的构建革命&lt;/h1>
&lt;p>我们的系统是一个使用 Vite 构建的 React 应用，包含超过 200 个页面、300+组件，随着业务的快速增长，开发团队面临着严峻的性能挑战：&lt;/p>
&lt;ul>
&lt;li>本地开发服务器启动时间超过 25 秒&lt;/li>
&lt;li>开发过程中的热更新延迟 3-5 秒&lt;/li>
&lt;li>生产环境构建耗时超过 2 分钟&lt;/li>
&lt;li>首屏加载时间超过 5 秒&lt;/li>
&lt;li>构建产物超过 8MB（gzip 后 2.8MB）&lt;/li>
&lt;/ul>
&lt;p>产品经理抱怨功能迭代速度太慢，开发人员则痛苦地等待每一次构建，测试团队需要忍受频繁的部署延迟。当我尝试理解代码库时，发现这个项目使用了基础的 Vite 配置，几乎没有进行任何优化。&lt;/p>
&lt;p>今天，我想分享如何将这个项目的构建时间从 2 分钟降至 8 秒，开发服务器启动时间降至 3 秒，同时将首屏加载速度提升 300%的全过程。&lt;/p>
&lt;h2 id="一项目初始状态分析">一、项目初始状态分析&lt;/h2>
&lt;p>首先，我进行了全面的性能分析，确定瓶颈所在：&lt;/p>
&lt;h3 id="1-构建分析">1. 构建分析&lt;/h3>
&lt;p>使用&lt;code>rollup-plugin-visualizer&lt;/code>创建构建分析报告：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// vite.config.js 初始状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">defineConfig&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;vite&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">react&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;@vitejs/plugin-react&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#a6e22e">defineConfig&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">plugins&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#a6e22e">react&lt;/span>()],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">build&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">minify&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;terser&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分析结果令人震惊：&lt;/p>
&lt;ul>
&lt;li>依赖包占总体积的 76%，其中有多个重复依赖&lt;/li>
&lt;li>主 bundle 文件超过 3MB&lt;/li>
&lt;li>图片和字体资源未经优化，占总体积的 22%&lt;/li>
&lt;li>React 组件未分割，导致首屏需要加载大量非必要代码&lt;/li>
&lt;li>未使用缓存策略，每次构建都是从零开始&lt;/li>
&lt;/ul>
&lt;h3 id="2-性能指标基线">2. 性能指标基线&lt;/h3>
&lt;p>使用 Lighthouse 和自定义性能监控工具收集的基线指标：&lt;/p></description></item><item><title>Web Security</title><link>https://www.yss520.online/zh/posts/web-security/</link><pubDate>Sat, 12 Aug 2023 00:21:02 +0800</pubDate><guid>https://www.yss520.online/zh/posts/web-security/</guid><description>&lt;h1 id="前端安全护城河从一场安全危机到体系化解决方案">前端安全护城河：从一场安全危机到体系化解决方案&lt;/h1>
&lt;p>安全是每一个开发离不开的话题，结合这些年的开发经理和一些实战经验，分享一些关于前端的安全思考&lt;/p>
&lt;h2 id="安全事件剖析看似简单的漏洞灾难性的后果">安全事件剖析：看似简单的漏洞，灾难性的后果&lt;/h2>
&lt;p>事件起因看似简单：管理后台的搜索功能直接展示了用户输入，没有任何过滤。攻击者通过精心构造的搜索词，注入了恶意 JavaScript，进而获取了管理员的认证令牌，最终导致大量用户数据泄露。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 原始的不安全代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">SearchResults&lt;/span>({ &lt;span style="color:#a6e22e">query&lt;/span> }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">div&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">h2&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">搜索结果&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {&lt;span style="color:#a6e22e">query&lt;/span>}&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">/h2&amp;gt; {/&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">直接注入用户输入&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#a6e22e">导致XSS漏洞&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">div&lt;/span> &lt;span style="color:#a6e22e">className&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;results&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#75715e">/* 搜索结果 */&lt;/span>}&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/div&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/div&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个简单漏洞只是冰山一角。安全审计发现了超过 30 个严重漏洞，包括多处 XSS、CSRF、敏感信息泄露、不安全的第三方依赖等。显然，这不是修补几个漏洞就能解决的问题，而是需要系统性重构。&lt;/p>
&lt;h2 id="建立全面安全防护体系">建立全面安全防护体系&lt;/h2>
&lt;p>我们构建了一个多层次的前端安全防护体系，从代码级别、架构层面和运行环境三个维度全面加固应用。&lt;/p>
&lt;h3 id="1-xss-防御不仅仅是转义">1. XSS 防御：不仅仅是转义&lt;/h3>
&lt;p>XSS（跨站脚本攻击）仍然是前端最常见且危害最大的安全威胁。原有项目中发现了 12 处 XSS 漏洞，主要集中在以下几个方面：&lt;/p>
&lt;ul>
&lt;li>直接将用户输入注入 DOM&lt;/li>
&lt;li>危险的&lt;code>innerHTML&lt;/code>使用&lt;/li>
&lt;li>不安全的第三方内容嵌入&lt;/li>
&lt;li>反射型 XSS 通过 URL 参数注入&lt;/li>
&lt;/ul>
&lt;p>解决方案远不止简单的 HTML 转义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 安全改造后的模式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">DOMPurify&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;dompurify&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">encodeHTML&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./security-utils&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 默认进行HTML编码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">SafeText&lt;/span>({ &lt;span style="color:#a6e22e">text&lt;/span> }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">span&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#a6e22e">encodeHTML&lt;/span>(&lt;span style="color:#a6e22e">text&lt;/span>)}&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/span&amp;gt;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 必须显式选择是否信任内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">RichContent&lt;/span>({ &lt;span style="color:#a6e22e">htmlContent&lt;/span>, &lt;span style="color:#a6e22e">trusted&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span> }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">trusted&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 即使是&amp;#34;可信&amp;#34;内容也进行清理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">sanitized&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">DOMPurify&lt;/span>.&lt;span style="color:#a6e22e">sanitize&lt;/span>(&lt;span style="color:#a6e22e">htmlContent&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ALLOWED_TAGS&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;i&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;em&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;strong&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;p&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ul&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ol&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;li&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ALLOWED_ATTR&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;href&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;target&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;rel&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">div&lt;/span> &lt;span style="color:#a6e22e">dangerouslySetInnerHTML&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{{ &lt;span style="color:#a6e22e">__html&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">sanitized&lt;/span> }} &lt;span style="color:#f92672">/&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 非可信内容只显示纯文本
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">div&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#a6e22e">encodeHTML&lt;/span>(&lt;span style="color:#a6e22e">htmlContent&lt;/span>)}&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/div&amp;gt;;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更重要的是，我们建立了安全编码规范和自动化检测机制：&lt;/p></description></item><item><title>Architecture and Performance</title><link>https://www.yss520.online/zh/posts/architecture-and-performance/</link><pubDate>Tue, 25 Jul 2023 22:13:24 +0800</pubDate><guid>https://www.yss520.online/zh/posts/architecture-and-performance/</guid><description>&lt;h1 id="现代前端架构设计与性能从分形到原子的性能提升之旅">现代前端架构设计与性能：从分形到原子的性能提升之旅&lt;/h1>
&lt;p>去年我负责重构了一个运行了 5 年的大型 B2B SaaS 平台。最初，它是一个单体 React 应用，代码超过 15 万行，运行缓慢且维护困难。经过 3 个月的架构重设计，我们将首屏加载时间从 8.6 秒降至 1.2 秒，内存使用减少 65%，交互响应从平均 600ms 提升至不到 100ms。更重要的是，开发效率提高了 3 倍，这种架构层面的优化影响深远，今天我想分享这段经历。&lt;/p>
&lt;h2 id="现代架构模式与性能的隐秘关系">现代架构模式与性能的隐秘关系&lt;/h2>
&lt;p>传统观点认为架构是为了可维护性，性能优化是单独的任务。实际上，正确的架构决策本身就能带来显著的性能提升。&lt;/p>
&lt;h3 id="从巨石到微前端拆分与懒加载的艺术">从巨石到微前端：拆分与懒加载的艺术&lt;/h3>
&lt;p>最初的单体应用含有超过 20 个主要业务模块，所有代码打包在一起，导致即使用户只需一个简单功能，也要加载整个应用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 原始入口文件 - 所有模块一次性加载
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;react&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">ReactDOM&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;react-dom&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">BrowserRouter&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;react-router-dom&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">Provider&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;react-redux&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 导入所有模块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">Dashboard&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./modules/dashboard&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">Inventory&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./modules/inventory&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">Orders&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./modules/orders&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">Analytics&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./modules/analytics&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">Users&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./modules/users&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">Settings&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./modules/settings&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ... 15个其他模块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">store&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./store&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">App&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./App&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ReactDOM&lt;/span>.&lt;span style="color:#a6e22e">render&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Provider&lt;/span> &lt;span style="color:#a6e22e">store&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">store&lt;/span>}&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">BrowserRouter&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">App&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/BrowserRouter&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/Provider&amp;gt;,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这导致初始 JavaScript 包达到 5.8MB，即使经过压缩也有 1.6MB。我们决定采用微前端架构，但不是盲目跟风，而是根据业务边界精确划分：&lt;/p></description></item><item><title>Browser Render</title><link>https://www.yss520.online/zh/posts/browser-render/</link><pubDate>Fri, 30 Jun 2023 00:02:26 +0800</pubDate><guid>https://www.yss520.online/zh/posts/browser-render/</guid><description>&lt;h1 id="深入浏览器渲染管线从像素到屏幕的性能优化之旅">深入浏览器渲染管线：从像素到屏幕的性能优化之旅&lt;/h1>
&lt;p>上个季度，我们团队接手了一个性能堪忧的大型 Dashboard 项目：60 多个图表、复杂的交互、频繁的数据更新，在中端设备上卡顿明显。用户反馈&amp;quot;点击按钮到 UI 响应需要 2-3 秒&amp;quot;，这绝对是灾难级体验。&lt;/p>
&lt;p>经过 8 周的深度优化，我们将交互延迟从平均 2.5 秒降至不到 100ms，流畅度提升了 25 倍。这个过程让我重新审视了浏览器渲染管线的每个环节，今天想分享这段深入像素级优化的心得。&lt;/p>
&lt;h2 id="浏览器渲染管线比想象中更复杂的过程">浏览器渲染管线：比想象中更复杂的过程&lt;/h2>
&lt;p>当我们谈论浏览器渲染，大多数开发者只知道关键词：DOM、CSSOM、RenderTree。但实际过程远比这三个步骤复杂得多。通过研究 Chromium 源码，我得以窥见浏览器渲染的完整过程。&lt;/p>
&lt;p>让我们先看一个简化但更全面的渲染流程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>JavaScript → Style → Layout → Layer → Paint → Composite
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个阶段的源码实现都极其复杂。以 Layout（布局）阶段为例，Chrome 中的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Chromium源码简化片段 - LayoutObject::UpdateLayout函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> LayoutObject&lt;span style="color:#f92672">::&lt;/span>UpdateLayout() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 检查是否需要完整布局
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (NeedsLayout()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// LayoutObject有不同类型，每种类型的布局算法不同
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (IsLayoutBlock()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ToLayoutBlock(&lt;span style="color:#66d9ef">this&lt;/span>)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>LayoutBlock();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span> (IsText()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ToLayoutText(&lt;span style="color:#66d9ef">this&lt;/span>)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>LayoutText();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 其他布局对象类型...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 递归布局子元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (LayoutObject&lt;span style="color:#f92672">*&lt;/span> child &lt;span style="color:#f92672">=&lt;/span> FirstChild(); child; child &lt;span style="color:#f92672">=&lt;/span> child&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NextSibling()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (child&lt;span style="color:#f92672">-&amp;gt;&lt;/span>NeedsLayout()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> child&lt;span style="color:#f92672">-&amp;gt;&lt;/span>UpdateLayout();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 清除布局标记
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ClearNeedsLayout();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// LayoutBlock对象的布局实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> LayoutBlock&lt;span style="color:#f92672">::&lt;/span>LayoutBlock() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 确定宽度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ComputeBlockWidth();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 布局子元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> LayoutChildren();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 确定高度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ComputeBlockHeight();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 处理溢出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ComputeOverflow();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码揭示了关键信息：浏览器布局是递归过程，一个简单的 DOM 结构变化可能触发整个树的重新布局。了解这一点对优化至关重要。&lt;/p></description></item><item><title>Front End Engineering</title><link>https://www.yss520.online/zh/posts/front-end-engineering/</link><pubDate>Sun, 11 Jun 2023 21:57:14 +0800</pubDate><guid>https://www.yss520.online/zh/posts/front-end-engineering/</guid><description>&lt;h1 id="前端构建系统的演进与优化从打包到无构建">前端构建系统的演进与优化：从打包到无构建&lt;/h1>
&lt;p>上个月我们团队重构了一个有 4 年历史的大型前端项目的构建系统，从老旧的 Webpack 配置迁移到现代化的 Vite 构建。预计需要两周的工作实际上花了一个月，但结果让人振奋：开发服务器启动时间从 40 秒降到不到 2 秒，构建时间减少了 70%，最终包体积缩小了 23%。这次经历让我重新审视了前端构建系统的发展历程，今天就来分享一些深度思考。&lt;/p>
&lt;h2 id="构建系统的底层原理比想象中复杂得多">构建系统的底层原理：比想象中复杂得多&lt;/h2>
&lt;p>当我们运行&lt;code>npm start&lt;/code>时，背后到底发生了什么？通过研究各种工具的源码，我发现构建工具远比我想象的复杂。&lt;/p>
&lt;p>先看看最基础的部分：模块解析。以 Webpack 为例，它的模块解析过程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// webpack源码简化版片段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createResolver&lt;/span>(&lt;span style="color:#a6e22e">options&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#a6e22e">context&lt;/span>, &lt;span style="color:#a6e22e">request&lt;/span>, &lt;span style="color:#a6e22e">callback&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从当前路径开始检索模块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">possiblePaths&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">path&lt;/span>.&lt;span style="color:#a6e22e">join&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>, &lt;span style="color:#a6e22e">request&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">path&lt;/span>.&lt;span style="color:#a6e22e">join&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;node_modules&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">request&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 一直向上查找node_modules
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 依次尝试每个可能的路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">modulePath&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">possiblePaths&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">fs&lt;/span>.&lt;span style="color:#a6e22e">existsSync&lt;/span>(&lt;span style="color:#a6e22e">modulePath&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">callback&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#a6e22e">modulePath&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 尝试扩展名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">ext&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;.js&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;.json&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;.node&amp;#34;&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">withExt&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">modulePath&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">ext&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">fs&lt;/span>.&lt;span style="color:#a6e22e">existsSync&lt;/span>(&lt;span style="color:#a6e22e">withExt&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">callback&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#a6e22e">withExt&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 模块未找到
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">callback&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> Error(&lt;span style="color:#e6db74">`Module not found: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">request&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来简单，但实际实现要考虑各种边缘情况：软链接、package.json 中的字段顺序、各种导入语法等。&lt;/p></description></item><item><title>React Server Render</title><link>https://www.yss520.online/zh/posts/react-server-render/</link><pubDate>Sun, 21 May 2023 22:24:27 +0800</pubDate><guid>https://www.yss520.online/zh/posts/react-server-render/</guid><description>&lt;h1 id="react-服务器组件重新思考前端与后端的边界">React 服务器组件：重新思考前端与后端的边界&lt;/h1>
&lt;p>两周前刚上线了我们团队花了 3 个月重构的电商平台，这次最大的技术挑战是全面采用了 React 服务器组件（Server Components）。这个决定确实带来了不少挑战，但效果令人惊喜：首屏加载时间减少了 62%，JS 包体积减少了 41%，而且开发体验出乎意料地好。今天想分享一下我们对服务器组件的探索历程和实战经验。&lt;/p>
&lt;h2 id="服务器组件不只是另一种-ssr">服务器组件：不只是另一种 SSR&lt;/h2>
&lt;p>第一次听说服务器组件时，我的反应是&amp;quot;这不就是 SSR 换了个名字吗？&amp;ldquo;通过深入研究源码和实践，我发现这是个根本性的误解。&lt;/p>
&lt;p>服务器组件（RSC）与传统服务端渲染（SSR）的区别，比想象中大得多：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 传统SSR：整个组件树在服务器渲染后，发送完整HTML到客户端，然后hydrate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 客户端需要下载整个组件的JS代码才能进行交互
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 服务器组件：只在服务器上运行，不发送组件代码到客户端
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 👇 这个组件的代码永远不会发送到客户端
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;use server&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">ProductDetails&lt;/span>({ &lt;span style="color:#a6e22e">id&lt;/span> }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 直接访问服务器资源(数据库、文件系统等)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">product&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">products&lt;/span>.&lt;span style="color:#a6e22e">findById&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">relatedProducts&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">products&lt;/span>.&lt;span style="color:#a6e22e">findRelated&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">div&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">h1&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#a6e22e">product&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>}&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/h1&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">p&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#a6e22e">product&lt;/span>.&lt;span style="color:#a6e22e">description&lt;/span>}&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/p&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">price&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#a6e22e">formatCurrency&lt;/span>(&lt;span style="color:#a6e22e">product&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span>)}&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/price&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#75715e">/* 可以在服务器上渲染客户端组件 */&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">AddToCartButton&lt;/span> &lt;span style="color:#a6e22e">productId&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">id&lt;/span>} &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#75715e">/* 可以引用其他服务器组件 */&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">RelatedProducts&lt;/span> &lt;span style="color:#a6e22e">products&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">relatedProducts&lt;/span>} &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/div&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>翻开 React 源码，可以看到服务器组件的本质是一种新的组件模型，它创建了一个跨服务器和客户端的渲染边界：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// React内部对服务器组件的处理（简化版）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">processServerComponent&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>, &lt;span style="color:#a6e22e">request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Component&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">type&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">props&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 调用组件函数获取结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Component&lt;/span>(&lt;span style="color:#a6e22e">props&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果结果是Promise（异步组件），则等待它完成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">isPromise&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span>.&lt;span style="color:#a6e22e">then&lt;/span>((&lt;span style="color:#a6e22e">resolved&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">serializeResult&lt;/span>(&lt;span style="color:#a6e22e">resolved&lt;/span>, &lt;span style="color:#a6e22e">request&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 序列化结果，包括将客户端组件替换为引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">serializeResult&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>, &lt;span style="color:#a6e22e">request&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">serializeResult&lt;/span>(&lt;span style="color:#a6e22e">node&lt;/span>, &lt;span style="color:#a6e22e">request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果是客户端组件，替换为对该组件的引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">isClientComponent&lt;/span>(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">type&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">$$typeof&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">REACT_ELEMENT_TYPE&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">CLIENT_REFERENCE&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">props&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">serializeProps&lt;/span>(&lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>, &lt;span style="color:#a6e22e">request&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 继续处理子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码展示了 React 如何处理服务器组件：它在服务器上执行组件，并将结果（而非组件代码）序列化后发送给客户端。这与传统 SSR 的&amp;quot;先在服务器渲染 HTML，再在客户端重新执行组件代码&amp;quot;完全不同。&lt;/p></description></item><item><title>React Node</title><link>https://www.yss520.online/zh/posts/react-node/</link><pubDate>Thu, 06 Apr 2023 21:41:19 +0800</pubDate><guid>https://www.yss520.online/zh/posts/react-node/</guid><description>&lt;h1 id="react-并发模式揭秘从源码看架构演进">React 并发模式揭秘：从源码看架构演进&lt;/h1>
&lt;p>上周收到一个棘手任务：优化我们的后台系统在低端设备上的性能。表格渲染、筛选、动画，一系列操作让老旧设备卡到崩溃。正好借此机会，我深入研究了 React 18 的并发渲染机制，发现这确实是把解决性能问题的利器。&lt;/p>
&lt;h2 id="并发模式react-架构的重大转变">并发模式：React 架构的重大转变&lt;/h2>
&lt;p>React 的并发模式可能是自 Hooks 以来最重大的架构变革。本质上，这是一种新的渲染模式，允许 React&lt;strong>中断、暂停和恢复&lt;/strong>渲染工作。这听起来很简单，但实现起来极其复杂，这也解释了为什么 React 团队花了近 5 年时间才将其正式发布。&lt;/p>
&lt;p>翻开源码，第一个关键概念是&lt;strong>优先级调度&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 简化版的任务优先级定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">DiscreteEventPriority&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">SyncLane&lt;/span>; &lt;span style="color:#75715e">// 最高优先级，如点击
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">ContinuousEventPriority&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">InputContinuousLane&lt;/span>; &lt;span style="color:#75715e">// 连续事件，如拖拽
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">DefaultEventPriority&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">DefaultLane&lt;/span>; &lt;span style="color:#75715e">// 默认优先级
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">IdleEventPriority&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">IdleLane&lt;/span>; &lt;span style="color:#75715e">// 空闲优先级
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些优先级常量不仅仅是数字，它们在 React 内部使用了一种称为&amp;quot;Lanes&amp;quot;的位字段表示法，这使得 React 可以高效地处理和比较多个优先级。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Lanes的实现（简化版）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">TotalLanes&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 将多个lane合并
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">mergeLanes&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 检查lanes中是否包含特定lane
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">includesSomeLane&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>) &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#a6e22e">NoLanes&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种位运算实现既高效又巧妙，让 React 能够用单个 32 位整数表示和处理多个优先级，避免了复杂数据结构带来的性能开销。&lt;/p>
&lt;h2 id="中断与恢复渲染的新范式">中断与恢复：渲染的新范式&lt;/h2>
&lt;p>并发模式最核心的能力是&amp;quot;中断与恢复&amp;quot;。在旧版 React 中，一旦开始渲染就必须完成，这在大型应用中可能导致明显的卡顿。&lt;/p>
&lt;p>在 React 18 中，渲染逻辑被重构为&amp;quot;workLoop&amp;quot;：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">workLoopConcurrent&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行工作，直到没有更多时间或工作完成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#a6e22e">workInProgress&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">shouldYield&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">performUnitOfWork&lt;/span>(&lt;span style="color:#a6e22e">workInProgress&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">shouldYield&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 检查是否需要让出控制权给浏览器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 检查是否有更高优先级的工作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">currentEventTransitionLane&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#a6e22e">NoLane&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 是否已经用完分配的时间片
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">scheduler&lt;/span>.&lt;span style="color:#a6e22e">unstable_shouldYield&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码展示了 React 是如何实现&amp;quot;可中断渲染&amp;quot;的：在&lt;code>workLoopConcurrent&lt;/code>中，React 会不断检查&lt;code>shouldYield()&lt;/code>，如果需要让出控制权（比如有更高优先级任务或时间片用完），它会暂停当前工作，并在稍后恢复。&lt;/p></description></item><item><title>React Hook</title><link>https://www.yss520.online/zh/posts/react-hook/</link><pubDate>Sun, 02 Apr 2023 18:14:17 +0800</pubDate><guid>https://www.yss520.online/zh/posts/react-hook/</guid><description>&lt;h2 id="hooks-的本质链表而非魔法">Hooks 的本质：链表而非魔法&lt;/h2>
&lt;p>刚开始使用 Hooks 时，&lt;code>useState&lt;/code>看起来像是某种&amp;quot;魔法&amp;quot;——一个普通函数竟然能记住上次渲染的状态。但翻开源码，发现其实现原理出奇简单：&lt;strong>就是一个链表&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 当前正在渲染的组件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">currentlyRenderingFiber&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 当前处理的Hook
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">currentHook&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 工作中的Hook链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">workInProgressHook&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// useState的简化实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">useState&lt;/span>(&lt;span style="color:#a6e22e">initialState&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取或创建当前Hook
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">hook&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">mountWorkInProgressHook&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 初始化state
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">hook&lt;/span>.&lt;span style="color:#a6e22e">memoizedState&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">initialState&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#34;function&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">initialState&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">initialState&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hook&lt;/span>.&lt;span style="color:#a6e22e">memoizedState&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">initialState&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建更新函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">dispatch&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">dispatchAction&lt;/span>.&lt;span style="color:#a6e22e">bind&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#a6e22e">currentlyRenderingFiber&lt;/span>, &lt;span style="color:#a6e22e">hook&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">hook&lt;/span>.&lt;span style="color:#a6e22e">memoizedState&lt;/span>, &lt;span style="color:#a6e22e">dispatch&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 创建新Hook并添加到链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">mountWorkInProgressHook&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">hook&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">memoizedState&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">baseState&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">baseQueue&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">workInProgressHook&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这是链表中的第一个Hook
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">currentlyRenderingFiber&lt;/span>.&lt;span style="color:#a6e22e">memoizedState&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">workInProgressHook&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">hook&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 添加到链表末尾
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">workInProgressHook&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">workInProgressHook&lt;/span>.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">hook&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">workInProgressHook&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看到这段代码，我恍然大悟。React 为每个函数组件创建了一个 Fiber 节点，在这个节点上挂载了一个 Hook 链表。每次调用&lt;code>useState&lt;/code>、&lt;code>useEffect&lt;/code>等 Hook 时，都会在这个链表上添加一个新节点。在后续渲染时，React 会沿着这个链表遍历，拿到对应位置的 Hook 数据。&lt;/p></description></item><item><title>React Event System</title><link>https://www.yss520.online/zh/posts/react-event-system/</link><pubDate>Fri, 31 Mar 2023 23:30:23 +0800</pubDate><guid>https://www.yss520.online/zh/posts/react-event-system/</guid><description>&lt;h1 id="揭秘-react-事件系统从源码看原理与优化">揭秘 React 事件系统：从源码看原理与优化&lt;/h1>
&lt;p>最近在研发团队内做了一次关于 React 事件系统的分享，反响不错，决定整理成文章分享出来。这是我读 React 源码系列的第二篇，上次分析了虚拟 DOM 的实现细节，这次聚焦事件系统。&lt;/p>
&lt;h2 id="事件系统被误解的-react-核心机制">事件系统：被误解的 React 核心机制&lt;/h2>
&lt;p>大多数 React 开发者可能知道 React 有自己的事件系统，但很少有人能说清它到底做了什么。翻开源码后才发现，React 的事件系统是个精心设计的复杂机制，远不止是简单的&amp;quot;语法糖&amp;quot;。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 常见的React事件绑定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&amp;lt;&lt;span style="color:#f92672">button&lt;/span> &lt;span style="color:#a6e22e">onClick&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">handleClick&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">点击&lt;/span>&amp;lt;/&lt;span style="color:#f92672">button&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这行看似普通的代码背后，隐藏着一整套事件处理机制。&lt;/p>
&lt;h2 id="事件委托理解-react-的事件绑定">事件委托：理解 React 的事件绑定&lt;/h2>
&lt;p>第一个关键发现：&lt;strong>React 并不会把事件直接绑定在 DOM 元素上&lt;/strong>。&lt;/p>
&lt;p>在 React 17 之前，所有事件都被委托到 document 节点上；React 17 之后，改为委托到 React 树的根 DOM 容器上：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// React 17前后的事件绑定位置变化（简化的源码）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// React 16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>document.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">dispatchEvent&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// React 17+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">rootNode&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">dispatchEvent&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过查看 Chrome DevTools 的 Event Listeners 面板，你会发现真正的事件监听器并不在你写 JSX 的元素上，而是在根节点上。&lt;/p>
&lt;p>这种事件委托有几个重要好处：&lt;/p>
&lt;ul>
&lt;li>减少内存占用（不用为每个元素都绑定事件）&lt;/li>
&lt;li>动态添加的元素也能响应事件&lt;/li>
&lt;li>简化了 React Fiber 树的更新逻辑&lt;/li>
&lt;/ul>
&lt;h2 id="合成事件不只是包装原生事件那么简单">合成事件：不只是包装原生事件那么简单&lt;/h2>
&lt;p>React 的&lt;code>SyntheticEvent&lt;/code>对象是对原生 DOM 事件的包装，但它做了很多额外工作：&lt;/p></description></item><item><title>React Virtual Dom</title><link>https://www.yss520.online/zh/posts/react-virtual-dom/</link><pubDate>Wed, 29 Mar 2023 23:26:33 +0800</pubDate><guid>https://www.yss520.online/zh/posts/react-virtual-dom/</guid><description>&lt;h1 id="拆解-react-虚拟-dom源码分析与实战思考">拆解 React 虚拟 DOM：源码分析与实战思考&lt;/h1>
&lt;p>最近几周在重构公司的一个核心项目，借此机会深入研读了 React 源码，尤其是虚拟 DOM 相关的实现。虽然网上关于虚拟 DOM 的文章不少，但很多停留在表面概念上，没有真正深入到源码细节。这篇文章我想从源码角度分享一些发现和思考。&lt;/p>
&lt;h2 id="虚拟-dom-的本质不只是性能优化">虚拟 DOM 的本质：不只是性能优化&lt;/h2>
&lt;p>我们常听说虚拟 DOM 是为了提高性能，但读源码后发现，性能优化其实只是它的附加效果之一。虚拟 DOM 更本质的价值在于提供了一个中间抽象层，简化了 UI 编程模型。&lt;/p>
&lt;p>React 中的虚拟 DOM 实际上是一个普通的 JavaScript 对象，大致结构如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// React元素的简化结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">$$typeof&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Symbol&lt;/span>(&lt;span style="color:#a6e22e">react&lt;/span>.&lt;span style="color:#a6e22e">element&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;div&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">props&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">className&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;container&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">$$typeof&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Symbol&lt;/span>(&lt;span style="color:#a6e22e">react&lt;/span>.&lt;span style="color:#a6e22e">element&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;h1&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">props&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Hello&amp;#39;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...其他属性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ref&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...其他内部属性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>$$typeof&lt;/code>是防止 XSS 攻击的安全措施，它是一个 Symbol，不能在 JSON 中被表示。&lt;/p>
&lt;h2 id="fiber-架构中的虚拟-dom">Fiber 架构中的虚拟 DOM&lt;/h2>
&lt;p>在 React 16 引入 Fiber 架构后，虚拟 DOM 的实现变得更加复杂。Fiber 节点不仅包含了虚拟 DOM 的信息，还包含了调度和渲染相关的额外字段:&lt;/p></description></item><item><title>我的第一篇文章</title><link>https://www.yss520.online/zh/posts/first-post/</link><pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.yss520.online/zh/posts/first-post/</guid><description>&lt;h1 id="欢迎来到我的博客">欢迎来到我的博客&lt;/h1>
&lt;p>这是我在新的Hugo博客上的第一篇文章。希望你喜欢！&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>这是一篇示例文章，向你展示Hugo和PaperMod主题的功能。&lt;/p>
&lt;h2 id="特点">特点&lt;/h2>
&lt;ul>
&lt;li>快速且轻量级&lt;/li>
&lt;li>对SEO友好&lt;/li>
&lt;li>响应式设计&lt;/li>
&lt;li>暗/亮模式&lt;/li>
&lt;li>目录&lt;/li>
&lt;li>多语言支持&lt;/li>
&lt;/ul></description></item></channel></rss>